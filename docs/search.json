[
  {
    "objectID": "placeholder.html",
    "href": "placeholder.html",
    "title": "\n1  Placeholder\n",
    "section": "",
    "text": "Hello world\n\n2+2\n\n[1] 4",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Placeholder</span>"
    ]
  },
  {
    "objectID": "course-notes.html",
    "href": "course-notes.html",
    "title": "Course Notes",
    "section": "",
    "text": "This section contains the notes from the course.\nHere is an overview of the content and corresponding assignments.",
    "crumbs": [
      "Course Notes"
    ]
  },
  {
    "objectID": "assignments.html",
    "href": "assignments.html",
    "title": "Assignments",
    "section": "",
    "text": "This section contains the assignments from the course.",
    "crumbs": [
      "Assignments"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DANA 320",
    "section": "",
    "text": "Overview\n&lt; insert table with links to each chapters and brief descriptions from the schedule &gt;\n\n\n\n\n\n\nQuarto blog publish details\n\n\n\nThis book was created using Quarto and published with Github Pages.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "hw-visualizations.html",
    "href": "hw-visualizations.html",
    "title": "\n2  HW - Visualizations\n",
    "section": "",
    "text": "Submission: Completed qmd file and rendered html file via Canvas.\nOverview\nThese problems apply the idea from the notes ‘3.2 – Visualizations’, where we learned how to create plots using in R using ggplot2.\nWe will be working with the ggplot2::msleep data (documentation), which contains information on mammals sleep patterns as well as some categorical variables about the species. A subset is shown below:\n\n\n\n\n\n\nname\n\n\ngenus\n\n\nvore\n\n\norder\n\n\nconservation\n\n\nsleep_total\n\n\nsleep_rem\n\n\nsleep_cycle\n\n\nawake\n\n\nbrainwt\n\n\nbodywt\n\n\n\n\n\nCheetah\n\n\nAcinonyx\n\n\ncarni\n\n\nCarnivora\n\n\nlc\n\n\n12.1\n\n\nNA\n\n\nNA\n\n\n11.9\n\n\nNA\n\n\n50.000\n\n\n\n\nOwl monkey\n\n\nAotus\n\n\nomni\n\n\nPrimates\n\n\nNA\n\n\n17.0\n\n\n1.8\n\n\nNA\n\n\n7.0\n\n\n0.01550\n\n\n0.480\n\n\n\n\nMountain beaver\n\n\nAplodontia\n\n\nherbi\n\n\nRodentia\n\n\nnt\n\n\n14.4\n\n\n2.4\n\n\nNA\n\n\n9.6\n\n\nNA\n\n\n1.350\n\n\n\n\nGreater short-tailed shrew\n\n\nBlarina\n\n\nomni\n\n\nSoricomorpha\n\n\nlc\n\n\n14.9\n\n\n2.3\n\n\n0.1333333\n\n\n9.1\n\n\n0.00029\n\n\n0.019\n\n\n\n\nCow\n\n\nBos\n\n\nherbi\n\n\nArtiodactyla\n\n\ndomesticated\n\n\n4.0\n\n\n0.7\n\n\n0.6666667\n\n\n20.0\n\n\n0.42300\n\n\n600.000\n\n\n\n\nThree-toed sloth\n\n\nBradypus\n\n\nherbi\n\n\nPilosa\n\n\nNA\n\n\n14.4\n\n\n2.2\n\n\n0.7666667\n\n\n9.6\n\n\nNA\n\n\n3.850\n\n\n\n\n\n\n\nAssignment\nThe goal is to recreate several plots in order to get used to the different types of and the structure of ggplot2 function calls and how to customize plots. The following prompts will take you through a series of plots representing an exploratory data analysis (EDA) where each plot is sequentially updated to new plot types or to incorporate more variables, each time revealing more information.\nPart a – Bar graphs\nLets first investigate the sample sizes of different categories within the dataset. Recreate the following bar graph for type of vore.\nNote this used the ggplot2::theme_bw() theme. To run a single command and set the theme for all the subsequent created plots, use ggplot2::theme_set() (check the documentation for more details).\n\n\n\n\n\n\n\n\n\n\nTo make this plot more readable, a first step we could do is sort the bars according to decreasing frequency (when we do this, it is technically called a “Pareto chart”). To do so, replace vore with the following line of code in your aes() statement: fct_infreq(vore). Check the help documentation of forcats::fct_infreq() to see what this function does.\n\n\n\n\n\n\n\n\n\n\nWe can also add the counts atop the bars just like adding data labels in Excel. To do this, add the following lines of code to the previous plot.\n\n&lt; previous bar graph function call &gt; +\n  geom_text(stat = \"count\",\n            aes(x = vore,\n                label = after_stat(count)),\n            vjust = -1)\n\nExplanation of code:\n- geom_text(stat = \"count\", aes(x = vore, label = after_stat(count))) counts the number of observations at each x vore value and uses the count as a label.\n- Then it places the text label by default at the top of each bar, and vjust = -1 moves the label one above the bar.\nBe sure to add nicer labels and title.\nPart b – Histograms and density curves\nRecreate the following histogram of sleep_total, paying attention to the changed aesthetics of the histogram.\n\n\n\n\n\n\n\n\n\n\nNotice that this histogram by default is really choppy, lets change the bins argument to a smaller value to see how it looks. Try a few different values.\nPerhaps a smooth curve would be a more accurate representation of this data than a histogram. Recreate the following density curve.\n\n\n\n\n\n\n\n\n\n\nLets add grouping information to the previous histogram to visualize sleep_total for each different type of vore. To do so, use the fill = vore to the aes() statement.\n\n\n\n\n\n\n\n\n\n\nIt is nearly impossible to glean any information from this plot. So let’s switch to a density curve, which is better for displaying several distributions on the same plot. Recreate the following plot, pay attention to which aesthetic vore needs to be mapped to.\n\n\n\n\n\n\n\n\n\n\nNow that we have a readable, accurate plot type for several distributions. Lets investigate more interesting quantities. Suppose we are interested in which animals have the biggest brains (proportionally). To study this we will visualize the ratio of brain weight to body weight based on the classification of animal vore. Recreate the following plot.\nHINTS:\n- Remember we can do “algebra” with our variables within an aes() statement.\n- To remove the NA category, we need to filter then out of the dataset used by ggplot(). We will learn how this function works in more detail next section, but for now replace msleep with the following code: filter(msleep, !is.na(vore)).\n- Essentially, is.na(vore) evaluates to TRUE when there is a missing value of NA and FALSE when not missing, then ! flips the logical so that filter() keeps only the non-missing values.\n\n\n\n\n\n\n\n\n\n\nBe sure to add descriptive title and axis label. Write a sentence in your qmd file summarizing the relationships shown in the resulting plot.\nPart c – Comparative boxplots\nAn alternative to multiple density curves is comparative boxplots. Create horizontal comparative boxplots for sleep_total by vore.\nNow convert this to a vertical comparative boxplots. Note that there are two ways this can be done. Be sure to add nice title and axis labels and change the overall color scheme of the boxplots to match the context of sleep. Write a sentence comparing the sleep totals for the different kind of vores.\nPart d – Scatterplots\nNow we will visualize two quantitative variables. Recreate the following scatterplot, which investigates the hours of rem sleep compared to the total sleep hours.\n\n# create scatterplot\nggplot(data = msleep) + \n  geom_point(aes(x = sleep_total,\n                 y = sleep_rem))\n\n\n\n\n\n\n\n\n\nThere appears to some kind of relationship between these two variables, which makes sense. The more total sleep an animal gets, the more REM sleep. Lets add model the relationship with a regression line. We can do this via the adding the following code to the previous plot.\n\n&lt; previous scatterplot function call &gt; +\n  geom_smooth(aes(x = sleep_total,\n                  y = sleep_rem),\n              method = \"lm\",\n              se = FALSE)\n\nTry commenting out method = \"lm\" to see the effect. Then change se = TRUE.\nBe sure to add nice titles and axis labels.\nIs it correct to model this relationship? REM sleep in hours per day is obviously a function of the sleep total; so there will implicitly be a relationship between these variables. To account for this, lets convert REM sleep to be relative to the total sleep hours by taking the ratio again like with brain weight and body weight. Create a new scatterplot with straight trend line for total sleep vs the ratio of REM sleep to total sleep.\nWrite a sentence describing the relationship between relative REM sleep and the total amount of sleep based on the this and the previous plot.\nPart e – Visualize data\nCreate at least one additional polished plot visualizing relationships among variable(s). Include a sentence write-up detailing any conclusions drawn from the plot. Feel free to create more than one :)",
    "crumbs": [
      "Assignments",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>HW - Visualizations</span>"
    ]
  },
  {
    "objectID": "hw-data-manipulations.html",
    "href": "hw-data-manipulations.html",
    "title": "\n5  HW - Data Manipulations\n",
    "section": "",
    "text": "Submission: Completed qmd file and rendered html file via Canvas.\nWhat will be looked at for grading: Correct code, output and sufficient write-ups where indicated.\nOverview\nThis problem ties together concepts and functions from all the previous R notes for a comprehensive data analysis problem.\nWe will be working with hypothetical student grade data data-grades.csv, which contains information on two test scores from students of multiple sections for a single professor, and enrollment data data-majors.csv, which has the students major.\n\n\n\n\n ID \n    Student \n    Test_1 \n    Test_2 \n  \n\n\n 1381 \n    LZ-1 \n    20 \n    55 \n  \n\n 2027 \n    KO-1 \n    30 \n    40 \n  \n\n 6077 \n    DD-1 \n    28 \n    68 \n  \n\n 6869 \n    IG-2 \n    14 \n    42 \n  \n\n 4171 \n    VS-1 \n    28 \n    50 \n  \n\n\n\n\n\n\n ID \n    Major \n  \n\n\n 9810 \n    Physics \n  \n\n 9718 \n    Physics \n  \n\n 9685 \n    Chemisty \n  \n\n 9618 \n    Chemisty \n  \n\n 9520 \n    Physics \n  \n\n\n\n\nTo read in the data, first download it from Canvas and then change the path in the read_csv() statement above to where you have saved the data relative to the location of the your homework file.\nThis assignment will take you through steps to clean, organize and analyze these the test scores.\nAssignment\nThe goal of this assignment is to demonstrate common data manipulation tasks using packages from the tidyverse.\nPart a – Data manipulations\nThe goal is to have a single dataset with the following columns:\n\nID\n\nStudent: just two initials\nMajor\n\nClass: 1 or 2\n\nTest_1: % out of 100\n\nTest_2: % out of 100\n\n\nFor the grades data, we need to split the current student column into two variables, one of their initials and one for the class they are in. Use tidyr::separate_wider_delim() to do so.\nConvert the test scores to percentages (Test 1 is out of 30 points and Test 2 is out of 70 points).\nCombine grades data and majors data and then sort alphabetically by student initials within each class.\nPart b – Visualize data\nNow that the data is cleaned and organized, lets visualize the Test 1 scores to start with.\nCreate two polished plots to visualize Test 1 scores, at least one of which should include a class comparison or major comparison.\nPart c – Summarize data\nNow that we have an idea of the distributions for Test 1, let’s summarize them, specifically we want to create an overall summary and a summary by class.\n\nCreate a test 1 dataset that contains only the Class, Student initials and Test 1 score.\nCreate an object named data_summary_overall that summarizes Test 1 scores with the sample size, average and standard deviation. Then add the following lines of code to add an indicator column and rearrange the columns.\n\n\ndata_summary_overall &lt;- &lt; previous summary function call &gt; %&gt;% \n  mutate(Class = \"Overall\") %&gt;% \n  select(4, 1:3)\n\n\nCreate another object called data_summary_section that performs the same summary functions the previous step, except by Class.\nCombine the overall summary with the class summary rowwise.\nPart d – More manipulations and visualizations 1\nIf we want to visualize both tests and class at the same time, some more data restructuring is necessary. Specifically, we need the data to have the following columns:\n\nID\n\nStudent: just two initials\nMajor\n\nClass: 1 or 2\n\nTest: 1 or 2\n\nGrade: % out of 100\n\nThus, there is two rows per student, one for each test grade.\nPerform the necessary data steps and then recreate the following visual. Note that two have the labels for Test 1 and Test 2 nicely formatted, the values need to be cleaned in the data.\n\n\n\n\n\n\n\n\n\n\nPart e – More manipulations and visualizations 2\nNow the professor wants to investigate applying a curve by major for Test 1 grades.\n\nUsing the Test 1 data from Part c, create a new dataset that also contains curved grades for Test 1 according to the following scheme:\n\n\nClass 1 receives 3 additional points.\nClass 2 receives a 30% of their missed points back (HINT: On paper work out an algebra function that accomplishes this and spot check a few values to make sure they are correct).\n\nHINT: Use case_when().\n\nUsing the curved data, perform the necessary data steps and then recreate the following visual.",
    "crumbs": [
      "Assignments",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>HW - Data Manipulations</span>"
    ]
  },
  {
    "objectID": "hw-data-transformations.html",
    "href": "hw-data-transformations.html",
    "title": "\n3  HW - Data Transformations\n",
    "section": "",
    "text": "Submission: Completed qmd file and rendered html file via Canvas.\nWhat will be looked at for grading: Correct code, output and sufficient write-ups where indicated.\nOverview\nThese problems apply the ideas from the notes ‘3.3 – Data Transformations’, where we learned how to modify datasets plots using in R using dplyr and uses the transformed data to make visualizations learned in notes ‘3.2 – Visualizations’.\nWe will be working with the shuffled-playlist.csv data, which contains information about songs in a Spotify playlist. A subset is shown below:\n\n# load data\ndata_music &lt;- read.csv(file = \"assignments/data/shuffled-playlist.csv\")\n\n# preview data\nhead(data_music)\n\n\n\n\n\nartist\n\n\nalbum\n\n\ngenre\n\n\nname\n\n\ndanceability\n\n\nenergy\n\n\nloudness\n\n\nspeechiness\n\n\nacousticness\n\n\ninstrumentalness\n\n\nliveness\n\n\nvalence\n\n\ntempo\n\n\n\n\n\nStreetlight+Manifesto\n\n\nEverything Goes Numb\n\n\nska\n\n\nA Moment of Violence\n\n\n0.609\n\n\n0.9180\n\n\n-5.998\n\n\n0.0894\n\n\n0.0087\n\n\n0.00e+00\n\n\n0.2940\n\n\n0.5410\n\n\n89.975\n\n\n\n\nAdele\n\n\n25\n\n\npop\n\n\nWater Under the Bridge\n\n\n0.596\n\n\n0.8380\n\n\n-6.520\n\n\n0.0704\n\n\n0.0189\n\n\n1.54e-05\n\n\n0.1080\n\n\n0.4790\n\n\n94.982\n\n\n\n\nPink Floyd\n\n\nThe Dark Side of the Moon\n\n\nclassic rock\n\n\nSpeak to Me\n\n\n0.592\n\n\n0.0196\n\n\n-33.350\n\n\n0.0358\n\n\n0.3620\n\n\n8.54e-01\n\n\n0.1080\n\n\n0.0322\n\n\n119.504\n\n\n\n\nChildish+Gambino\n\n\n\"Awaken, My Love!\"\n\n\nhip hop\n\n\nBaby Boy\n\n\n0.529\n\n\n0.4030\n\n\n-7.103\n\n\n0.0349\n\n\n0.1230\n\n\n4.96e-01\n\n\n0.0647\n\n\n0.7230\n\n\n199.928\n\n\n\n\nEd+Sheeran\n\n\nDivide (Deluxe)\n\n\npop\n\n\nNancy Mulligan\n\n\n0.680\n\n\n0.8520\n\n\n-4.350\n\n\n0.0349\n\n\n0.1170\n\n\n0.00e+00\n\n\n0.0866\n\n\n0.8520\n\n\n101.993\n\n\n\n\nKendrick+Lamar\n\n\nTo Pimp A Butterfly\n\n\nhip hop\n\n\nYou Ain’t Gotta Lie (Momma Said)\n\n\n0.501\n\n\n0.6460\n\n\n-5.422\n\n\n0.2310\n\n\n0.4820\n\n\n1.43e-05\n\n\n0.2740\n\n\n0.6480\n\n\n94.746\n\n\n\n\n\n\n\nTo read in the data, first download it from Canvas and then change the path in the read.csv() statement above to where you have saved the data relative to the location of the your homework file.\nAssignment\nThe goal of this assignment is to demonstrate common data manipulation tasks using dplyr and creating more plots from transformed data with ggplot2. You will be asked several questions about the music dataset that can be answered by working with the data and then you will create some simple plots focused on particular aspects of the data.\nPart a – Data cleaning\nFirst we will do some data cleaning. Notice in the above preview how the spaces are  are actually plus signs + in the artist names. Use a mutate() statement to overwrite artist with the following line of code: str_replace_all(string = artist, pattern =  \"\\\\+\", replacement = \" \"). Also overwrite data_music so that it is updated with the cleaned artist information.\nExplanation of code:\n- str_replace_all() is part of a package very useful for working with strings. This function in particular finds all occurrences of + and replaces them with a space \" \".\n- Note that the pattern matching is done via what is called “regular expressions”. And + is a special character in regular expressions, so we have to preface it with a double escape character in R \\\\. If you are curious about more regular expression patterns, see this cheatsheet and the documentation for ?str_replace.\n\n\n\n\n\n\nartist\n\n\nalbum\n\n\ngenre\n\n\nname\n\n\ndanceability\n\n\nenergy\n\n\nloudness\n\n\nspeechiness\n\n\nacousticness\n\n\ninstrumentalness\n\n\nliveness\n\n\nvalence\n\n\ntempo\n\n\n\n\n\nStreetlight Manifesto\n\n\nEverything Goes Numb\n\n\nska\n\n\nA Moment of Violence\n\n\n0.609\n\n\n0.9180\n\n\n-5.998\n\n\n0.0894\n\n\n0.0087\n\n\n0.00e+00\n\n\n0.2940\n\n\n0.5410\n\n\n89.975\n\n\n\n\nAdele\n\n\n25\n\n\npop\n\n\nWater Under the Bridge\n\n\n0.596\n\n\n0.8380\n\n\n-6.520\n\n\n0.0704\n\n\n0.0189\n\n\n1.54e-05\n\n\n0.1080\n\n\n0.4790\n\n\n94.982\n\n\n\n\nPink Floyd\n\n\nThe Dark Side of the Moon\n\n\nclassic rock\n\n\nSpeak to Me\n\n\n0.592\n\n\n0.0196\n\n\n-33.350\n\n\n0.0358\n\n\n0.3620\n\n\n8.54e-01\n\n\n0.1080\n\n\n0.0322\n\n\n119.504\n\n\n\n\nChildish Gambino\n\n\n\"Awaken, My Love!\"\n\n\nhip hop\n\n\nBaby Boy\n\n\n0.529\n\n\n0.4030\n\n\n-7.103\n\n\n0.0349\n\n\n0.1230\n\n\n4.96e-01\n\n\n0.0647\n\n\n0.7230\n\n\n199.928\n\n\n\n\nEd Sheeran\n\n\nDivide (Deluxe)\n\n\npop\n\n\nNancy Mulligan\n\n\n0.680\n\n\n0.8520\n\n\n-4.350\n\n\n0.0349\n\n\n0.1170\n\n\n0.00e+00\n\n\n0.0866\n\n\n0.8520\n\n\n101.993\n\n\n\n\nKendrick Lamar\n\n\nTo Pimp A Butterfly\n\n\nhip hop\n\n\nYou Ain’t Gotta Lie (Momma Said)\n\n\n0.501\n\n\n0.6460\n\n\n-5.422\n\n\n0.2310\n\n\n0.4820\n\n\n1.43e-05\n\n\n0.2740\n\n\n0.6480\n\n\n94.746\n\n\n\n\n\n\n\nPart b – Summarize data\n\nDetermine the number of rows in the dataset. Then use an in-line R statement to write a sentence that is dynamically updated based on your calculation. For example, if I calculate the number of rows and save it as the object n_rows, then my sentence will read “There are &lt; n_rows &gt; in the dataset.”, where &lt; n_rows &gt; pulls from your calculation.\n\nFor each of the following questions, use pipes %&gt;% (or a series of pipes) to display a mini-dataframe that answers the question (there is no need to save the results into an object).\n\nWhat song has the highest valence score? Display only the categorical information about the song (i.e. artist, album, genre, name) and its respective valence score. HINT: use a select() statement in conjunction with where() to display only the character variables.\nWhat is the average energy for hip hop songs?\nWhat percentage of songs in the data are by the artist Dessa?\nPart c – Grouped and specific summaries\n\nCalculate the average energy, tempo and loudness for each genre. First do this by having a separate mean(&lt; variable &gt;) statement for each.\nNow repeat the calculation using across(), which allows us to apply the same function to a set of variables. This is much less cumbersome than typing each mean statement out like before.\nUse the same technique as above to calculate the mean of all numeric variable by genre.\nDetermine which pop song is the most danceable (highest danceability). Display only the categorical information about the song and its respective danceability score. HINT: Think about the series of pipes that we need to do.\nUse the same strategy to determine which which Adele song has the lowest energy.\nCHALLENGE: Find the artists with the lowest average acousticness for each genre.\nPart d – Visualize data\nNow we will create some plots based on subsets of the data.\n\nCreate a dataset of only hip hop songs and make bar graph for the number of songs by each artist. Add data labels atop the bars and change the color scheme of the bars.\nFind which three artists have the most songs in this playlist. To do this create a dataframe in descending order according to song count. Then create a scatterplot of speechiness vs liveness for only the top three artists. Include a sentence write-up describing the relationship in the scatterplot.\n\nCHALLENGE: Setup the code in such a way to create the scatterplot without ever explicitly naming the top 3 artists, e.g. never coding Fleetwood Mac. This makes your code much more dynamic.\n\nHow do the tempos compare for the artist within the ska genre? Create comparative boxplots to display this and include a sentence write-up summarizing the results.\nPart e – Analyze data\n\nAsk and answer another question about this dataset using a combination of “data steps” like in parts b and c.\nCreate an additional plot of your choosing that tells an interesting story about the data. This plot must use data that has been transformed in some way. Describe this plot in a few sentences.",
    "crumbs": [
      "Assignments",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>HW - Data Transformations</span>"
    ]
  },
  {
    "objectID": "lab-data-cleaning.html",
    "href": "lab-data-cleaning.html",
    "title": "\n4  Lab - Data Cleaning\n",
    "section": "",
    "text": "Submission: Completed qmd file and rendered html file via Canvas.\nWhat will be looked at for grading: Correct code, output and sufficient write-ups where indicated.\nOverview\nThis problem applies the ideas from the notes ‘3.4 – Reshaping and Combining Data’, where we learned to restructure datasets, and also uses functions from dplyr functions from ‘3.3 – Data Transformations’.\nWe will be working with the midwest-gas-prices.csv data, which contains the average weekly midwestern fuel prices for a gallon of regular unleaded gasoline from November 1994 to May 2012. We want to use this data to create a time series line-plot of the data that looks like the image below:\n\n\n\n\n\n\nThe problem is that the data is very messy and improperly structured to create this visualization. Here is how the data file is structured in Excel and how it would read directly into R.\n\n\n\n\n\n\n\n\n\n\n Year.Month \n    Week.1 \n    X \n    Week.2 \n    X.1 \n    Week.3 \n    X.2 \n    Week.4 \n    X.3 \n    Week.5 \n    X.4 \n  \n\n\n  \n    End Date \n    Value \n    End Date \n    Value \n    End Date \n    Value \n    End Date \n    Value \n    End Date \n    Value \n  \n\n 1994-Nov \n     \n     \n     \n     \n     \n     \n    11/28/16 \n    1.122 \n     \n     \n  \n\n 1994-Dec \n    12/5/16 \n    1.086 \n    12/12/16 \n    1.057 \n    12/19/16 \n    1.039 \n    12/26/16 \n    1.027 \n     \n     \n  \n\n 1995-Jan \n    1/2/16 \n    1.025 \n    1/9/16 \n    1.046 \n    1/16/16 \n    1.031 \n    1/23/16 \n    1.054 \n    1/30/16 \n    1.055 \n  \n\n 1995-Feb \n    2/6/16 \n    1.045 \n    2/13/16 \n    1.04 \n    2/20/16 \n    1.031 \n    2/27/16 \n    1.052 \n     \n     \n  \n\n\n\n\nThis assignment will take you through steps to resolve all of the structural issues with the current data and also clean it.\nAssignment\nThe goal of this assignment is to restructure and clean the data in R using the dplyr, tidyr, stringr, and lubridate packages.\nOverview of the current setup of data:\n\nCurrently the data is very messy and improperly structured to create the desired visualization.\nThere is one column for year/mon.\nPrices and more dates are spread across multiple columns, all with bad labels.\nAnd all date columns are character variables.\n\nOur end goal for the data is as follows to have a data frame that has only two columns: date and price. Complete each of the following steps in order to ultimately recreate the visual of interest.\nPart a – Import data\nThe header of this data is two rows of poorly formatted labels. When you read in the data you will want to skip over the header using the options in the read_csv() function.\nHere is the result after properly being read in:\n\n\n\n\n ...1 \n    End Date...2 \n    Value...3 \n    End Date...4 \n    Value...5 \n    End Date...6 \n    Value...7 \n    End Date...8 \n    Value...9 \n    End Date...10 \n    Value...11 \n  \n\n\n 1994-Nov \n    NA \n    NA \n    NA \n    NA \n    NA \n    NA \n    11/28/16 \n    1.122 \n    NA \n    NA \n  \n\n 1994-Dec \n    12/5/16 \n    1.086 \n    12/12/16 \n    1.057 \n    12/19/16 \n    1.039 \n    12/26/16 \n    1.027 \n    NA \n    NA \n  \n\n 1995-Jan \n    1/2/16 \n    1.025 \n    1/9/16 \n    1.046 \n    1/16/16 \n    1.031 \n    1/23/16 \n    1.054 \n    1/30/16 \n    1.055 \n  \n\n 1995-Feb \n    2/6/16 \n    1.045 \n    2/13/16 \n    1.040 \n    2/20/16 \n    1.031 \n    2/27/16 \n    1.052 \n    NA \n    NA \n  \n\n 1995-Mar \n    3/6/16 \n    1.053 \n    3/13/16 \n    1.042 \n    3/20/16 \n    1.048 \n    3/27/16 \n    1.065 \n    NA \n    NA \n  \n\n\n\n\nPart b – Reshape data\nThe first column has the year/month combined followed by five pairs of columns for the dates and prices associated with weeks 1 through 5 of each month. Each of these five column pairs will need to be moved from wide format to long format using functions in the tidyr package.\nNote that this will be made much easier if you:\n\nFirst create separate data frames with the columns of dates and columns of prices\nThen pivot the columns in each\nThen recombine after they have both been reformatted wide-to-long.\n\nHere is what the price information should look like:\n\n\n\n\n price \n  \n\n\n NA \n  \n\n NA \n  \n\n NA \n  \n\n 1.122 \n  \n\n NA \n  \n\n 1.086 \n  \n\n 1.057 \n  \n\n 1.039 \n  \n\n 1.027 \n  \n\n NA \n  \n\n\n\n\nAnd now the date information:\n\n\n\n\n year_month \n    unneeded_column \n    month_day \n  \n\n\n 1994-Nov \n    End Date...2 \n    NA \n  \n\n 1994-Nov \n    End Date...4 \n    NA \n  \n\n 1994-Nov \n    End Date...6 \n    NA \n  \n\n 1994-Nov \n    End Date...8 \n    11/28/16 \n  \n\n 1994-Nov \n    End Date...10 \n    NA \n  \n\n 1994-Dec \n    End Date...2 \n    12/5/16 \n  \n\n 1994-Dec \n    End Date...4 \n    12/12/16 \n  \n\n 1994-Dec \n    End Date...6 \n    12/19/16 \n  \n\n 1994-Dec \n    End Date...8 \n    12/26/16 \n  \n\n 1994-Dec \n    End Date...10 \n    NA \n  \n\n\n\n\nPart c – Clean data\nFor the date information, extra steps are needed after reshaping.\n\nNotice that the years for each date are listed as 2016 in the month/day column, this needs to be replaced with the real year from the year/month column. I suggest using a combination of the stringr::str_sub() and the paste() function to fix the year.\nAfter you get the date column similar to “mm/dd/yyyy” or “mm-dd-yy”, you can use lubridate::mdy() to transform the column to a POSIX date-formatted variable.\n\n\n\n\n\n date \n  \n\n\n NA \n  \n\n NA \n  \n\n NA \n  \n\n 1994-11-28 \n  \n\n NA \n  \n\n 1994-12-05 \n  \n\n 1994-12-12 \n  \n\n 1994-12-19 \n  \n\n 1994-12-26 \n  \n\n NA \n  \n\n\n\n\nPart d – Combine data\nNow we can combine the date and price data back together with base R cbind() or dplyr::bind_cols() in order to create the final desired dataset for the visualization.\n\n\n\n\n date \n    price \n  \n\n\n NA \n    NA \n  \n\n NA \n    NA \n  \n\n NA \n    NA \n  \n\n 1994-11-28 \n    1.122 \n  \n\n NA \n    NA \n  \n\n 1994-12-05 \n    1.086 \n  \n\n 1994-12-12 \n    1.057 \n  \n\n 1994-12-19 \n    1.039 \n  \n\n 1994-12-26 \n    1.027 \n  \n\n NA \n    NA \n  \n\n\n\n\nPart e – Visualize data\nNow recreate the desired visualization using the final dataset.",
    "crumbs": [
      "Assignments",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lab - Data Cleaning</span>"
    ]
  },
  {
    "objectID": "visualizations.html",
    "href": "visualizations.html",
    "title": "\n2  Visualizations\n",
    "section": "",
    "text": "2.0.1 Overview\nMaterials\n&lt; links &gt;\nThis section\n\nThis section introduces the world of ggplot2, several different types of plots, and some basic features to enhance your visuals. Then it covers simple data visualization principles when working with multiple variables and how to implement these within ggplot2.\n\n\n\n\n\n\n\nReadings\n\n\nThis section covers content from Chapter 2 - Data Visualization of R for Data Science (2e).\n\nAdditional content includes section 10.4 - Facets and 10.5 - Statistical Transformations.\n\n\nggplot2 help documentation contains everything you need to know about ggplot2, including a very helpful cheatsheet.\nPrerequisites\n\nBefore we can use the functions, datasets, and help pages within the tidyverse, which includes ggplot2, we need to load the package. We can do this by running:\n\n\nlibrary(tidyverse)\n\n\nNote if any package is not currently installed, it cannot be loaded. We can install packages using the ‘Packages’ tab or by running:\n\n\ninstall.packages(\"tidyverse\")\n\nGoal\n\nOur goal by the end of this section is to be able to understand all the aspects of the following plots, how to create them, and how to set up the plot to easily switch between different layouts.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.0.2 Example dataset\n\nWe are going to use diamonds dataset from ggplot2 package, aka ggplot2::diamonds (this is the syntax for denoting which package a function or dataset comes from packagename::functionname()). This contains price and other attribute information about a large sample of diamonds.\nYou can search a function or dataset name in the ‘Help’ tab or run ?&lt; function or dataset &gt; to bring up the documentation.\n\n\n?diamonds\n\n\nTo preview the dataset, we can click on it in the ‘Environment’ tab or run glimpse(), which shows a better formatted preview than the standard print() function.\nDisplayed results compactly show the number of observations, the number of variables and their corresponding data types and also some of the raw data.\n\n\nglimpse(diamonds)\n\nRows: 53,940\nColumns: 10\n$ carat   &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.…\n$ cut     &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver…\n$ color   &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,…\n$ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, …\n$ depth   &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64…\n$ table   &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58…\n$ price   &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34…\n$ x       &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.…\n$ y       &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.…\n$ z       &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.…\n\n\n\n2.0.3 ggplot2 basics and scatterplots\nBuilding from scratch\n\nggplot2 builds plots based on an approach called the grammar of graphics (hence “gg”plot2).\nThe grammar of graphics approach requires explicit aesthetic mapping of data to geometric features.\nAll plots follow a similar structure that builds up from the ggplot() function, which creates a “blank canvas”.\nAnd the first thing we can do is specify the dataset we will be using and rerun the code.\n\n\nggplot(data = diamonds)\n\n\n\n\n\n\n\n\n\n\nNow it is primed with the data, but we haven’t told it to do anything.\nAesthetic mapping\n\nNext, we can add a layer of geometric features with geom_*(). This uses uses aesthetic mapping, which takes values of a variable and translates them into a visual feature.\nChoice of geometry depends on the data types of the variables of interest from the supplied dataset as well as the intent for creating the plot.\nIn the example below, both variables (carat and price) are continuous. So we can use a scatterplot visualize their relationship. This is created by adding a layer of points via geom_point().\nSimply use + between ggplot2 functions to add layers.\n\n\nggplot(data = diamonds,\n       x = carat,\n       y = price) + \n  geom_point()\n\nError in `geom_point()`:\n! Problem while setting up geom.\nℹ Error occurred in the 1st layer.\nCaused by error in `compute_geom_1()`:\n! `geom_point()` requires the following missing aesthetics: x and y\n\n\n\nThe code above throws an error because R can’t find carat and price because it is looking for standalone objects (i.e. vectors named carat and price).\nSo to tell R that the attributes are from the diamonds dataset, use the aes() function. In other words, this function connects the plot features to the dataframe specified in the data argument. Lets correct the above code.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = price)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nExercise\n\nUse the code chunk below to create a scatterplot for table vs depth.\n\n\nggplot(data = diamonds,\n       aes(x = table,\n           y = depth)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nOther attributes\n\nNow we can adapt the scatterplot from above to learn more about function structure. Lets try to change the color of the points. A reasonable first attempt would be to specify a color argument.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = price,\n           color = \"purple\")) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\nThis does not work as hoped. Because we specified within the aes() function, ggplot() looks for the column purple in the dataset.\nSo when it doesn’t find one, a new column purple is made and assigned this same value to every observation. And because this new column is being mapped to the color of the dots, ggplot() colors accordingly (although it’s not what we wanted).\nThe solution to change the color of all data points is to relocate the color argument.\nAnything that is a simple “constant” value (i.e. not part of the data and just an option for visual look) should be specified locally and outside of the aes() function.\nSo lets correct it.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = price)) + \n  geom_point(color = \"purple\")\n\n\n\n\n\n\n\n\n\nIncorporating more variables via aes()\n\n\nOnly data-driven attributes go inside the aes() function.\nTo see how this works, let’s take a look at the iris dataset.\n\n\nglimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\n\n\nFor this example, we want to create a scatterplot for Sepal.Length vs Sepal.Width and color each observation based on Species, while also changing the style of dot for every point.\nNote that color is a data-driven feature, and size / shape are simply constants.\n\n\nggplot(data = iris,\n       aes(x = Sepal.Length,\n           y = Sepal.Width,\n          color = Species)) + \n  geom_point(size = 10,\n             shape = \"*\")\n\n\n\n\n\n\n\n\n\nExercise\n\n\nUsing the code chunk below, create a scatterplot using a sample of the diamonds dataset that includes the following features (code for the sample is provided, check the help page to see how it works!):\n\nVisualizes table vs depth;\nEach observation is sized based on the weight carat;\nAll observations have the shape of a diamond. HINT: Google “geom_point() shapes”.\n\n\n\n\ndiamonds_sample &lt;- sample_n(diamonds, size = 100)\n\n\nNow lets take a look at some different types of plots and more options to spruce them up.\n\n2.0.4 Histograms\ngeom_histogram()\n\nA basic histogram is a univariate plot that can be used for continuous variables and is created via geom_histogram().\nBelow we will code an example that shows the required mapping (i.e. arguments needed within the aes() function along with some other relevant arguments for geom_histogram().\nSearch the help page for each geom_* to see which aesthetics are required and what else can be modified.\n\n\nggplot(data = diamonds,\n       aes( x = carat)) + \n  geom_histogram(binwidth = 0.1,\n                 fill = \"red\",\n                 color = \"purple\")\n\n\n\n\n\n\n\n\n\n\nNow let’s use the iris data to make another histogram, except we are going to incorporate another variable; specifically we want to visualize on the petal lengths based on which species they are.\nNote that to map species to the color of the bars, the fill argument should be used (using the color attribute only changes the outline color of the bars).\n\n\nggplot(data = iris,\n       aes(x = Petal.Length,\n           fill = Species)) + \n  geom_histogram()\n\n\n\n\n\n\n\n\n\nExercise\n\nUse the code chunk below to create a histogram for carat that has 20 bins with white bars and black outlines.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_histogram(bins = 20,\n                 fill = \"white\",\n                 color = \"black\")\n\n\n\n\n\n\n\n\n\nTitles and labels\n\nWe can use of the labs() function which adds main titles, axis titles, etc. These labels can be tacked onto any ggplot2 plot. Let’s try it below.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_histogram(binwidth = 0.1,\n                 fill = \"red\",\n                 color = \"purple\") + \n  labs(title = \"Histogram of diamond weights\",\n       x = \"Weight in carats\",\n       y = \"Count\")\n\n\n\n\n\n\n\n\n\nExercise\n\n\nUsing the code chunk below, modify the code used to make the previous plot to:\n\nVisualize sepal length instead of petal length;\nChange the X-axis label to be more readable;\nGive the plot an informative title.\n\n\n\n\nggplot(data = iris,\n       aes(x = Sepal.Length,\n           fill = Species)) + \n  geom_histogram() + \n  labs(title = \"Sepal Length by Species\",\n       x = \"Sepal Length (cm)\")\n\n\n\n\n\n\n\n\n\n\n2.0.5 Boxplots\ngeom_boxplot()\n\nBoxplots are another common plot, which are used to visualize the distribution of a numeric variable. However, they no longer map the raw data.\nInstead, geom_boxplot() maps the five number summary that is computed from the raw data.\n\n\nx &lt;- rnorm(50)\nsummary(x)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-1.77293 -0.72336 -0.26939 -0.08506  0.43118  2.14445 \n\nboxplot(x)\n\n\n\n\n\n\n\n\nhist(x)\n\n\n\n\n\n\n\n\n\n\nThis is an example of when an aesthetic has an implicit transformation, which is then used to build the plot rather than straight from the raw data.\ngeom_boxplot() requires a continuous variable to be mapped to either the x or y argument, depending on the desired orientation of the boxplot.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nExercise\n\nUsing the code chunk below, create a vertical boxplot of Sepal.Length using the iris dataset.\n\n\nggplot(data = iris,\n       aes(y = Sepal.Length)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nComparitive boxplots\n\nWe can also make comparative (side-by-side) boxplots by mapping a categorical variable to the other axis. Lets see how to this works.\n\n\nggplot(data = diamonds,\naes(x = carat,\n    y = cut)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nThis results in boxplots based on a single continuous variable, but grouped by the levels of the categorical variable. This is one way to plot a numerical response with a categorical explanatory variable.\nAn advantage of this is that they are easier for comparing centers (medians) and spread (IQR), and can also highlights outliers. However with big data, it will often show many outliers that aren’t actually outliers (because the spread gets smaller and smaller as \\(n\\) increases).\nTransformations and more customizations\n\nWe can do transformations of the input variables directly within the ggplot() call, without having to modify the data object itself.\nJust like the other geoms, we can modify some visual aspects of the layer.\nThen if we want to swap the axes, we can use coord_flip(); this is one of many functions that can be used for further customization of most ggplots (others include scale_*(), theme_*(), etc.).\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           y = price/1000)) + \n  geom_boxplot(fill = \"darkblue\",\n               color = \"lightblue\") + \n  coord_flip() + \n  theme_classic()\n\n\n\n\n\n\n\n\n\nExercise\n\n\nUsing the code chunk below, create a comparative boxplot using the iris dataset that includes the following features:\n\nCompares Sepal.Length for each Species;\nHorizontal boxplots (more than one way to do this);\nSepal.Length is originally measured in millimeters (mm); convert this to meters (m) for this plot;\nMore informative axis label for Sepal.Length based on new scale;\nA cool theme (try a few!).\n\n\n\n\n# NOTE: if have X and Y aesthetics swapped, can use coord_flip() to get horizontal boxplots without changing your aes() statement\nggplot(data = iris,\n       aes(x = Species,\n           y = Sepal.Length / 10)) +  \n  geom_boxplot() + \n  labs(y = \"Sepal Length (m)\") + \n  theme_light()\n\n\n\n\n\n\n\n\n\n\n2.0.6 Bar graphs\nBar graphs\n\nA bar graph (also known as bar chart or bar plot) is used for categorical data and assigns a height of a bar to the count of a group.\nComparisons are made easier with visuals than just numbers (although keep in mind that sometimes simpler is better and a table suffices).\nJust like a boxplot, a bar graph is not plotting the raw data itself. Rather it uses a summary of the data, specifically the frequency (or relative frequency = frequency / total)\nThere are two ways we can use geom_bar() to make our bar graph, and it depends on the structure of the data.\ngeom_bar() wtih raw data\n\nOne way to make a bar graph is to just use the raw data and let geom_bar() convert the data into counts behind the scenes, as shown below.\nLets take a look at the data before plotting.\n\n\n\n\n\n\n\ncarat\n\n\ncut\n\n\ncolor\n\n\nclarity\n\n\ndepth\n\n\ntable\n\n\nprice\n\n\nx\n\n\ny\n\n\nz\n\n\n\n\n\n0.23\n\n\nIdeal\n\n\nE\n\n\nSI2\n\n\n61.5\n\n\n55\n\n\n326\n\n\n3.95\n\n\n3.98\n\n\n2.43\n\n\n\n\n0.21\n\n\nPremium\n\n\nE\n\n\nSI1\n\n\n59.8\n\n\n61\n\n\n326\n\n\n3.89\n\n\n3.84\n\n\n2.31\n\n\n\n\n0.23\n\n\nGood\n\n\nE\n\n\nVS1\n\n\n56.9\n\n\n65\n\n\n327\n\n\n4.05\n\n\n4.07\n\n\n2.31\n\n\n\n\n0.29\n\n\nPremium\n\n\nI\n\n\nVS2\n\n\n62.4\n\n\n58\n\n\n334\n\n\n4.20\n\n\n4.23\n\n\n2.63\n\n\n\n\n0.31\n\n\nGood\n\n\nJ\n\n\nSI2\n\n\n63.3\n\n\n58\n\n\n335\n\n\n4.34\n\n\n4.35\n\n\n2.75\n\n\n\n\n0.24\n\n\nVery Good\n\n\nJ\n\n\nVVS2\n\n\n62.8\n\n\n57\n\n\n336\n\n\n3.94\n\n\n3.96\n\n\n2.48\n\n\n\n\n\n\n\n\nBy “raw data”, we mean there is one row for each observation. When this is the case, we don’t have to change any options in geom_bar().\n\n\nggplot(data = diamonds,\n       aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\ngeom_bar() wtih count data\n\nAnother way is to manually create the counts dataframe (aka frequency table) and make the bar graph from this summarized data.\nThere are multiple ways to calculate the frequencies of each group in a dataframe. Two ways are shown below, using Base R table() and the other using a tidyverse function dplyr::count().\n\n\nclass(table(cut = diamonds$cut))\n\n[1] \"table\"\n\ndata.frame(table(cut = diamonds$cut))\n\n\n\n\n\ncut\n\n\nFreq\n\n\n\n\n\nFair\n\n\n1610\n\n\n\n\nGood\n\n\n4906\n\n\n\n\nVery Good\n\n\n12082\n\n\n\n\nPremium\n\n\n13791\n\n\n\n\nIdeal\n\n\n21551\n\n\n\n\n\n\ncut_table &lt;- count(diamonds, cut)\nglimpse(cut_table)\n\nRows: 5\nColumns: 2\n$ cut &lt;ord&gt; Fair, Good, Very Good, Premium, Ideal\n$ n   &lt;int&gt; 1610, 4906, 12082, 13791, 21551\n\n\n\nNow we have the frequency table, we can go into plotting it. But it will be different than how we used geom_bar() last time because we are giving it already summarized data.\nSpecifically we have the group label (our x) and the now specified count (height, y); so, we need to tell geom_bar() to not do any statistical transformation on these variables (i.e. don’t count again). To do this, we use the option stat = \"identity\".\n\n\nggplot(data = cut_table,\n       aes(x = cut,\n           y = n)) + \n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n\n\nJust like with most things, there is still another way to do this: geom_col() treats the y aesthetic as heights directly and we don’t have to specify anything else.\n\n\nggplot(data = cut_table,\n       aes(x = cut,\n           y = n)) + \n  geom_col()\n\n\n\n\n\n\n\n\n\nExercise\n\nUsing the code chunk below, create a bar graph of Species using a sample from the iris dataset provided below.\n\n\nHINT: Make sure to inspect the data first.\n\n\n\n# create a sample from of data and summarize\n# -&gt; rename so in slightly different format than example and have to work with it\niris_sample &lt;- iris %&gt;% \n  sample_n(size = 50) %&gt;% \n  count(Species) %&gt;% \n  rename(Count = n)\n\n\niris_sample\n\n\n\n\n\nSpecies\n\n\nCount\n\n\n\n\n\nsetosa\n\n\n17\n\n\n\n\nversicolor\n\n\n19\n\n\n\n\nvirginica\n\n\n14\n\n\n\n\n\n\n\n\n# preview dataset to figure out structure\nglimpse(iris_sample) #-&gt; count (summarized) data\n\nRows: 3\nColumns: 2\n$ Species &lt;fct&gt; setosa, versicolor, virginica\n$ Count   &lt;int&gt; 17, 19, 14\n\n# create bar graph\n# -&gt; way 1)\nggplot(data = iris_sample,\n       aes(x = Species,\n           y = Count)) + \n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n# -&gt; way 2)\nggplot(data = iris_sample,\n       aes(x = Species,\n           y = Count)) + \n  geom_col()\n\n\n\n\n\n\n\n\n\nDisplays for bivariate categorical data\nStacked bar graph\n\nA common extension of a barplot is to show the breakdown of a second categorical variable within each bar. One way to do this is with a stacked bar graph.\nWe can again use geom_bar() (and let it do the counting). In order to differentiate between the two variables, we can specify fill in the aes(), just like we did with geom_histogram().\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = clarity)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nNotice that the y-axis on the plot is count, so all of the bars and segments are based on the frequency.\nProportionally stacked bar graph\n\nIf we want the plot to be more standardized-ish, we can make a proportionally stacked bar graph by specifying position = \"fill\". This makes each bar have the same height and the segments corresponding to the second variable are broken out by percentage within each individual bar.\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = clarity)) + \n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n\n\nThis makes across group comparisons valid and easier because segments are no longer based on potentially very different sample sizes (technically, we are plotting the conditional distributions of clarity for each type of cut).\nThe advantage of this display is that we can see if there are differences in the distributions of clarity across each cut (regardless of how many total diamonds belong to each cut).\nSide-by-side bar graph\n\nWe can also incorporate the second variable by having side-by-side bars rather than stacked. To do this, we just have to set position = \"dodge\".\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = clarity)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\nThis display may tell a better story if it is important to keep an idea of sample size for each group combination. We can still tell that there are the most “Ideal” cut diamonds.\nExercise\n\nUsing the code chunk below, create a few different displays using the diamonds dataset that visualize cut and color together. Can you notice any trends or lack-thereof between the two variables? Explain.\n\n\n# two of several plots that could be made\n\n# side-by-side bar graphs\nggplot(data = diamonds,\n       aes(x = color,\n           fill = cut)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n# proportionally stacked bar graph\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = color)) + \n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n# trends\n# -&gt; colors E, F, amd G are the three most common\n# -&gt; distributions of color are relatively the same across cuts (i.e. about same proportion of diamonds for each color regardless of cut)\n\n\n2.0.7 Line plots\ngeom_line()\n\nAnother type of plot is a line plot. These are most commonly used when looking at a quantitative variable across time periods (aka time series data).\nBelow is a look at the example data sunspot.year. As usual we should get familiar with the data first.\n\n\nglimpse(sunspot.year)\n\n Time-Series [1:289] from 1700 to 1988: 5 11 16 23 36 58 29 20 10 8 ...\n\n\n\nBefore plotting, we need to turn this into a dataframe and add a column indicating the year.\n\n\ndata_sun &lt;- data.frame(year = c(1700:1988),\n                       sunspots = as.vector(sunspot.year))\nglimpse(data_sun)\n\nRows: 289\nColumns: 2\n$ year     &lt;int&gt; 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1…\n$ sunspots &lt;dbl&gt; 5, 11, 16, 23, 36, 58, 29, 20, 10, 8, 3, 0, 0, 2, 11, 27, 47,…\n\n\n\nThis is an easy plot to make, just use geom_line() and specify the x, which is usually time, and y within the aes().\n\n\nggplot(data = data_sun,\n       aes(x = year,\n           y = sunspots)) + \n  geom_line()\n\n\n\n\n\n\n\n\n\n\n2.0.8 Facets\nFacets\n\nFacets (think subplots) are a data-driven feature that can be used to compare distributions based on the levels of other variables.\nVisually, this is done by splitting plots into different panels rather than one overall panel. There are multiple ways this can be done within ggplot2.\nfacet_wrap()\n\nIf we are facetting by one categorical variable, we want to use facet_wrap(~ var).\nNote: the tilde ~ is used to make formula in R.\nLet’s create a scatterplot and add facets for cut to demonstrate this.\n\n\nggplot(data = diamonds,\n       aes(x = table,\n           y = depth)) + \n  geom_point() + \n  facet_wrap(~ cut)\n\n\n\n\n\n\n\n\n\n\nWe see that facet_wrap() “wraps” the panels for a single factor rectangularly, which is ideal when there are many levels for the factor.\nControlling rows and columns\n\nIf we want to control how the panels are wrapped because we are trying to highlight some aspect, we can specify how many rows or columns of panels using the options nrow and ncol.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_boxplot() + \n  facet_wrap(~ cut,\n             ncol = 1)\n\n\n\n\n\n\n\n\n\n\nJust be careful of overplotting, don’t want too many panels stacked together.\n\n\nggplot(data = diamonds,\n       aes(x = price)) + \n  geom_histogram() + \n  facet_wrap(~ clarity,\n             ncol = 1)\n\n\n\n\n\n\n\n\n\nScales for facets\n\nBy default, all the panels will have the same scale for the numeric variable. This can distort some plots as shown below.\n\n\nggplot(data = diamonds,\n       aes(x = price)) + \n  geom_histogram() + \n  facet_wrap(~ cut)\n\n\n\n\n\n\n\n\n\n\nTo make the plots more readable, we can add an option to allow panels to have scales (min, max, tick marks, etc.) based on only the data in the respective panel, rather than the collective data.\nThis is done via the scales argument; options are \"free_x\", \"free_y\" or \"free\" (both \\(x\\) and \\(y\\) scales are free).\nNow we can correct the above plot.\n\n\nggplot(data = diamonds,\n       aes(x = price)) + \n  geom_histogram() + \n  facet_wrap(~ cut,\n             scales = \"free_y\")\n\n\n\n\n\n\n\n\n\n\nThis is another way to display numerical distributions for multiple groups. The advantage of creating multiple histograms is that they can show prevalence (i.e. frequencies) and modality of the distributions, whereas boxplots cannot.\nExercise\n\n\nUsing the code chunk below, create a boxplots using the iris dataset that includes the following features:\n\nPlots Sepal.Length faceted by Species;\nStack the facets vertically to emphasize the differences between each Species;\nThink about if we want to adjust the scales of the panel, why or why not?\n\n\nNote that we made this plot previously with comparitive boxplots by specifying aes(y = Species); so this is an alternative.\n\n\nggplot(data = iris,\n       aes(x = Sepal.Length)) +  \n  geom_boxplot() + \n  facet_wrap(~ Species,\n             ncol = 1)\n\n\n\n\n\n\n\n\n# we do NOT want to use scales = \"free_x\" because in order to have an equal comparison of the boxplots across species, we need them to be on the same scale\n\nfacet_grid()\n\nIf we want to facet by two categorical variables, we should use facet_grid(var1 ~ var 2) as it can make a matrix of panels.\nNote that var1 (before ~) represents the rows and var2 (after) is the columns.\nLets create boxplots for each combination of cut and color for the diamonds dataset.\n\n\nggplot(data = diamonds,\n       aes(x = table)) + \n  geom_boxplot() + \n  facet_grid(cut ~ color)\n\n\n\n\n\n\n\n\n\n\nNote that when using facet_grid(), we may need to fix the scales in the same way as with facet_wrap(). And just because we can make the plot means that it is good…\nExercise\n\nUsing the code chunk below, create scatterplots of carat vs price that is colored by cut and facetted by color and clarity. Try a few different options for scales to see how they affect the plot.\n\n\n# create a sample from of data with fewer levels (variety from ordinal scale of each)\ndiamonds_sample &lt;- diamonds %&gt;% \n  filter(cut %in% unique(diamonds$cut)[c(1,3,5)],\n         color %in% unique(diamonds$color)[c(1,4,7)],\n         clarity %in% unique(diamonds$clarity)[c(1,4,8)]) %&gt;% \n  sample_n(size = 5000)\n\n\nggplot(data = diamonds_sample,\n       aes(x = carat,\n           y = price,\n           color = cut)) + \n  geom_point() + \n  facet_grid(color ~ clarity,\n             scales = \"free\") # both X and Y axes to be free (for the grid, not each individual panel)\n\n\n\n\n\n\n\n\n\n\n2.0.9 Density histograms and density curves\nDensity histograms\n\nAs we saw in the previous topic, if comparing a numeric distribution for a categorical explanatory variable, multiple histograms are a good option. But we had to allow varying scales between panels in order to have a readable plot.\nAnother option if we are not concerned with counts (sample size), but rather shape and modality across groups, is to make the heights of bars proportional.\nWe can think of this as each histogram having the same amount of “ink”, whcih is done by adding the condition that total heights must sum to 1. In essence, this standardizes heights.\nTo do this, we map y = after_stat(density) in the aes() statement (we won’t dig into how this works).\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = after_stat(density))) + \n  geom_histogram() + \n  facet_wrap(~ cut)\n\n\n\n\n\n\n\n\n\n\nThis can of course be done for a single histogram too.\nDensity curves\n\nA density curve is related to the density histograms we just showed.\nAs we have seen, (density) histograms are really choppy binned representations of data whose display can vary widely based on our selection of bin width / number of bins.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = after_stat(density))) + \n  geom_histogram(bins = 50)\n\n\n\n\n\n\n\n\n\n\nA more objective way to represent the data is called a density curve, which is a smooth curve based off the observed data that has an area under the curve (AUC) of 1.\nWe can think of this smooth curve as a blanket thrown over the top of our density histogram as shown below.\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how the density curve still reflects the overall pattern of histograms, but it is much smoother.\nTo create this by itself, use geom_density().\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_density()\n\n\n\n\n\n\n\n\n\nExercise\n\n\nUsing the code chunk below, use the iris dataset to do the following:\n\nCreate a density histogram of Petal.Length;\nOverlay a density curve of Petal.Length.\n\n\n\n\nHINT: You can plot multiple geoms on the same plot simply by adding another layer.\n\n\nggplot(data = iris,\n       aes(x = Petal.Length,\n           y = after_stat(density))) + \n  geom_histogram() + \n  geom_density()\n\n\n\n\n\n\n\n\n\nMultiple density curves\n\nDensity curves provide us with yet another way to visualize a quantitative distribution by group.\nDrawing multiple lines (density curves) on the same plot is often better than many histograms, because the histograms would have to be stacked.\nTo distinguish between different groups when working with lines, we could use the aesthetics linetype or color (color will likely be easier to read, especially for several groups).\nWe can also add some other options to make the lines stand out more.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           color = cut)) + \n  geom_density(linewidth = 0.75)\n\n\n\n\n\n\n\n\n\n\nJust be careful to not let the plot to get jumbled / messy with too many lines.\nAmount of smoothing\n\nOne way to tweak the resulting curve is to change the amount of smoothing, which is a statistical parameter (not just a visual one like binwidth). To do this, use the adjust parameter.\nIf adjustment is larger (e.g. adjust = 2), then the probability is more spread out and there is less smoothing; if smaller (e.g adjust = 0.2), then the smoothing is more sensitive and picks up on smaller patterns / spikes in the data.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_density(adjust = 2)\n\n\n\n\n\n\n\n\n\nExercise\n\n\nUsing the code chunk below, use the iris dataset to do the following:\n\nCreate density curves of a Petal.Length colored by each Species;\nAdjust the amount of smoothing to find a level that shows the overall trends well with some detail, but that is not overly exact (it’s a balance);\nAdd fill = Species in the aes() statement to see the result of this;\nNotice how the colors are completely opaque (not “see through”). To make them more transparent, add the following option locally geom_density(alpha = 0.5). Try a few different values (0 \\le alpha \\le 1) to see the result. Note that this option can also be used with lots other geom_*() as well.\nWhat does this plot tell us about the petal lengths of the different species?\n\n\n\n\nggplot(data = iris,\n       aes(x = Petal.Length,\n           color = Species,\n           fill = Species)) + \n  geom_density(adjust = 1,\n               alpha = 0.5)\n\n\n\n\n\n\n\n\n# two of the species have similar petal lengths, while one is well below the others\n\n\n2.0.10 Application\nRecreating\n\nNow we will return to the plots in the beginning of this section and recreate them.\n\n\n# load basketball data\nload(\"tutorials/visualizations/www/data-bsu-game.RData\")\n\n# filter to most recent season and take out the few neutral games\ndata_bsu_plot &lt;- bsu_game %&gt;% \n  filter(Season == max(Season),\n         Location != \"Neutral\")\n\n\n# line plot of points over the season\n# -&gt; specific colors by W/L and also take into account location with either the points (Visual 1)\n# -&gt; add reference line for average points\nggplot(data = data_bsu_plot,\n       aes(x = Date,\n           y = Points)) + \n  geom_point(aes(color = Outcome,\n                 shape = Location),\n             size = 4) + \n  geom_line(color = \"lightgrey\") + \n  geom_hline(aes(yintercept = mean(Points)),\n             color = \"grey20\",\n             linetype = \"dashed\") + \n  scale_color_manual(values = c(\"L\" = \"red\", \"W\" = \"green\")) + \n  scale_shape_manual(values = c(\"Home\" = 19, \"Away\" = 5, \"Neutral\" = 8)) + \n  labs(title = \"Ball State Basketball 2012-13 Visual 1\") + \n  theme_bw()\n\n\n\n\n\n\n\n\n\nExercise\n\nUsing the code chuck below, copy the final code used to create `Visual 1’ from above and modify it to recreate ‘Visual 2’.\n\n\n# line plot of points over the season\n# -&gt; specific colors by W/L and also take into account location with facet (Visual 2)\n# -&gt; add reference line for average points\nggplot(data = data_bsu_plot,\n       aes(x = Date,\n           y = Points)) + \n  geom_point(aes(color = Outcome,\n                 shape = Location),\n             size = 4) + \n  geom_line(color = \"lightgrey\") + \n  geom_hline(aes(yintercept = mean(Points)),\n             color = \"grey20\",\n             linetype = \"dashed\") + \n  scale_color_manual(values = c(\"L\" = \"red\", \"W\" = \"green\")) + \n  scale_shape_manual(values = c(\"Home\" = 19, \"Away\" = 5, \"Neutral\" = 8)) + \n  labs(title = \"Ball State Basketball 2012-13 Visual 1\") + \n  theme_bw()\n\n\n\n\n\n\n\n\nggplot(data = data_bsu_plot,\n       aes(x = Date,\n           y = Points)) +  \n  geom_point(aes(color = Outcome),\n             size = 4) + \n  geom_line(color = \"lightgrey\") + \n  geom_hline(aes(yintercept = mean(Points)),\n             color = \"grey20\",\n             linetype = \"dashed\") + \n  scale_color_manual(values = c(\"L\" = \"red\", \"W\" = \"green\")) + \n  facet_wrap(~ Location) + \n  labs(title = \"Ball State Basketball 2012-13 Visual 2\") + \n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n2.0.11 Exercise solutions\nExercise 2.0.3.6\n\n# create sample\ndiamonds_sample &lt;- sample_n(diamonds, size = 100)\n\n# create scatterplot\nggplot(data = diamonds_sample,\n       aes(x = table,\n           y = depth,\n           size = carat)) +\n  geom_point(shape = 5)",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#overview",
    "href": "visualizations.html#overview",
    "title": "\n2  Visualizations\n",
    "section": "\n2.1 Overview",
    "text": "2.1 Overview\n\n2.1.1 Materials\n\nAttached are all of the supplemental materials to this content! Feel free to check them out :)\n\nClick the image below or follow the link to access the interactive tutorial that corresponds to this content: http://coltongearhart.shinyapps.io/visualizations\n\n\nHere is the video that goes through the tutorial:\n\n\n\nAnd finally here is the starter file mentioned and needed data for one of the exercises: visulaizations - STARTER.qmd\n\n\n2.1.2 This section\n\nThis section introduces the world of ggplot2, several different types of plots, and some basic features to enhance your visuals. Then it covers simple data visualization principles when working with multiple variables and how to implement these within ggplot2.\n\n\n\n\n\n\n\n\n2.1.3 Readings\n\n\nThis section covers content from Chapter 2 - Data Visualization of R for Data Science (2e).\n\nAdditional content includes section 10.4 - Facets and 10.5 - Statistical Transformations.\n\n\nggplot2 help documentation contains everything you need to know about ggplot2, including a very helpful cheatsheet.\n\n2.1.4 Prerequisites\n\nBefore we can use the functions, datasets, and help pages within the tidyverse, which includes ggplot2, we need to load the package. We can do this by running:\n\n\nlibrary(tidyverse)\n\n\nNote if any package is not currently installed, it cannot be loaded. We can install packages using the ‘Packages’ tab or by running:\n\n\ninstall.packages(\"tidyverse\")\n\n\n2.1.5 Goal\n\nOur goal by the end of this section is to be able to understand all the aspects of the following plots, how to create them, and how to set up the plot to easily switch between different layouts.",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#example-dataset",
    "href": "visualizations.html#example-dataset",
    "title": "\n2  Visualizations\n",
    "section": "\n2.2 Example dataset",
    "text": "2.2 Example dataset\n\nWe are going to use diamonds dataset from ggplot2 package, aka ggplot2::diamonds (this is the syntax for denoting which package a function or dataset comes from packagename::functionname()). This contains price and other attribute information about a large sample of diamonds.\nYou can search a function or dataset name in the ‘Help’ tab or run ?&lt; function or dataset &gt; to bring up the documentation.\n\n\n?diamonds\n\n\nTo preview the dataset, we can click on it in the ‘Environment’ tab or run glimpse(), which shows a better formatted preview than the standard print() function.\nDisplayed results compactly show the number of observations, the number of variables and their corresponding data types and also some of the raw data.\n\n\nglimpse(diamonds)\n\nRows: 53,940\nColumns: 10\n$ carat   &lt;dbl&gt; 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.…\n$ cut     &lt;ord&gt; Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver…\n$ color   &lt;ord&gt; E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,…\n$ clarity &lt;ord&gt; SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, …\n$ depth   &lt;dbl&gt; 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64…\n$ table   &lt;dbl&gt; 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58…\n$ price   &lt;int&gt; 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34…\n$ x       &lt;dbl&gt; 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.…\n$ y       &lt;dbl&gt; 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.…\n$ z       &lt;dbl&gt; 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.…",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#ggplot2-basics-and-scatterplots",
    "href": "visualizations.html#ggplot2-basics-and-scatterplots",
    "title": "\n2  Visualizations\n",
    "section": "\n2.3 ggplot2 basics and scatterplots",
    "text": "2.3 ggplot2 basics and scatterplots\n\n2.3.1 Building from scratch\n\nggplot2 builds plots based on an approach called the grammar of graphics (hence “gg”plot2).\nThe grammar of graphics approach requires explicit aesthetic mapping of data to geometric features.\nAll plots follow a similar structure that builds up from the ggplot() function, which creates a “blank canvas”.\nAnd the first thing we can do is specify the dataset we will be using and rerun the code.\n\n\nggplot(data = diamonds)\n\n\n\n\n\n\n\n\n\n\nNow it is primed with the data, but we haven’t told it to do anything.\n\n2.3.2 Aesthetic mapping\n\nNext, we can add a layer of geometric features with geom_*(). This uses uses aesthetic mapping, which takes values of a variable and translates them into a visual feature.\nChoice of geometry depends on the data types of the variables of interest from the supplied dataset as well as the intent for creating the plot.\nIn the example below, both variables (carat and price) are continuous. So we can use a scatterplot visualize their relationship. This is created by adding a layer of points via geom_point().\nSimply use + between ggplot2 functions to add layers.\n\n\nggplot(data = diamonds,\n       x = carat,\n       y = price) + \n  geom_point()\n\nError in `geom_point()`:\n! Problem while setting up geom.\nℹ Error occurred in the 1st layer.\nCaused by error in `compute_geom_1()`:\n! `geom_point()` requires the following missing aesthetics: x and y\n\n\n\nThe code above throws an error because R can’t find carat and price because it is looking for standalone objects (i.e. vectors named carat and price).\nSo to tell R that the attributes are from the diamonds dataset, use the aes() function. In other words, this function connects the plot features to the dataframe specified in the data argument. Lets correct the above code.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = price)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n2.3.3 Exercise\n\nCreate a scatterplot for table vs depth.\n\n2.3.4 Other attributes\n\nNow we can adapt the scatterplot from above to learn more about function structure. Lets try to change the color of the points. A reasonable first attempt would be to specify a color argument.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = price,\n           color = \"purple\")) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\nThis does not work as hoped. Because we specified within the aes() function, ggplot() looks for the column purple in the dataset.\nSo when it doesn’t find one, a new column purple is made and assigned this same value to every observation. And because this new column is being mapped to the color of the dots, ggplot() colors accordingly (although it’s not what we wanted).\nThe solution to change the color of all data points is to relocate the color argument.\nAnything that is a simple “constant” value (i.e. not part of the data and just an option for visual look) should be specified locally and outside of the aes() function.\nSo lets correct it.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = price)) + \n  geom_point(color = \"purple\")\n\n\n\n\n\n\n\n\n\n\n2.3.5 Incorporating more variables via aes()\n\n\nOnly data-driven attributes go inside the aes() function.\nTo see how this works, let’s take a look at the iris dataset.\n\n\nglimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length &lt;dbl&gt; 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  &lt;dbl&gt; 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length &lt;dbl&gt; 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  &lt;dbl&gt; 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      &lt;fct&gt; setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n\n\n\nFor this example, we want to create a scatterplot for Sepal.Length vs Sepal.Width and color each observation based on Species, while also changing the style of dot for every point.\nNote that color is a data-driven feature, and size / shape are simply constants.\n\n\nggplot(data = iris,\n       aes(x = Sepal.Length,\n           y = Sepal.Width,\n          color = Species)) + \n  geom_point(size = 10,\n             shape = \"*\")\n\n\n\n\n\n\n\n\n\n\n2.3.6 Exercise\n\n\nCreate a scatterplot using a sample of the diamonds dataset that includes the following features (code for the sample is provided, check the help page to see how it works!):\n\nVisualizes table vs depth;\nEach observation is sized based on the weight carat;\nAll observations have the shape of a diamond. HINT: Google “geom_point() shapes”.\n\n\n\n\ndiamonds_sample &lt;- sample_n(diamonds, size = 100)\n\n\nNow lets take a look at some different types of plots and more options to spruce them up.",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#histograms",
    "href": "visualizations.html#histograms",
    "title": "\n2  Visualizations\n",
    "section": "\n2.4 Histograms",
    "text": "2.4 Histograms\n\n2.4.1 geom_histogram()\n\nA basic histogram is a univariate plot that can be used for continuous variables and is created via geom_histogram().\nBelow we will code an example that shows the required mapping (i.e. arguments needed within the aes() function along with some other relevant arguments for geom_histogram().\nSearch the help page for each geom_* to see which aesthetics are required and what else can be modified.\n\n\nggplot(data = diamonds,\n       aes( x = carat)) + \n  geom_histogram(binwidth = 0.1,\n                 fill = \"red\",\n                 color = \"purple\")\n\n\n\n\n\n\n\n\n\n\nNow let’s use the iris data to make another histogram, except we are going to incorporate another variable; specifically we want to visualize on the petal lengths based on which species they are.\nNote that to map species to the color of the bars, the fill argument should be used (using the color attribute only changes the outline color of the bars).\n\n\nggplot(data = iris,\n       aes(x = Petal.Length,\n           fill = Species)) + \n  geom_histogram()\n\n\n\n\n\n\n\n\n\n\n2.4.2 Exercise\n\nCreate a histogram for carat that has 20 bins with white bars and black outlines.\n\n2.4.3 Titles and labels\n\nWe can use of the labs() function which adds main titles, axis titles, etc. These labels can be tacked onto any ggplot2 plot. Let’s try it below.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_histogram(binwidth = 0.1,\n                 fill = \"red\",\n                 color = \"purple\") + \n  labs(title = \"Histogram of diamond weights\",\n       x = \"Weight in carats\",\n       y = \"Count\")\n\n\n\n\n\n\n\n\n\n\n2.4.4 Exercise\n\n\nModify the code used to make the previous plot to:\n\nVisualize sepal length instead of petal length;\nChange the X-axis label to be more readable;\nGive the plot an informative title.",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#boxplots",
    "href": "visualizations.html#boxplots",
    "title": "\n2  Visualizations\n",
    "section": "\n2.5 Boxplots",
    "text": "2.5 Boxplots\n\n2.5.1 geom_boxplot()\n\nBoxplots are another common plot, which are used to visualize the distribution of a numeric variable. However, they no longer map the raw data.\nInstead, geom_boxplot() maps the five number summary that is computed from the raw data.\n\n\nx &lt;- rnorm(50)\nsummary(x)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-1.75368 -0.65938  0.19142  0.09735  0.74754  2.92200 \n\nboxplot(x)\n\n\n\n\n\n\n\n\nhist(x)\n\n\n\n\n\n\n\n\n\n\nThis is an example of when an aesthetic has an implicit transformation, which is then used to build the plot rather than straight from the raw data.\ngeom_boxplot() requires a continuous variable to be mapped to either the x or y argument, depending on the desired orientation of the boxplot.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n2.5.2 Exercise\n\nCreate a vertical boxplot of Sepal.Length using the iris dataset.\n\n2.5.3 Comparitive boxplots\n\nWe can also make comparative (side-by-side) boxplots by mapping a categorical variable to the other axis. Lets see how to this works.\n\n\nggplot(data = diamonds,\naes(x = carat,\n    y = cut)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\nThis results in boxplots based on a single continuous variable, but grouped by the levels of the categorical variable. This is one way to plot a numerical response with a categorical explanatory variable.\nAn advantage of this is that they are easier for comparing centers (medians) and spread (IQR), and can also highlights outliers. However with big data, it will often show many outliers that aren’t actually outliers (because the spread gets smaller and smaller as \\(n\\) increases).\n\n2.5.4 Transformations and more customizations\n\nWe can do transformations of the input variables directly within the ggplot() call, without having to modify the data object itself.\nJust like the other geoms, we can modify some visual aspects of the layer.\nThen if we want to swap the axes, we can use coord_flip(); this is one of many functions that can be used for further customization of most ggplots (others include scale_*(), theme_*(), etc.).\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           y = price/1000)) + \n  geom_boxplot(fill = \"darkblue\",\n               color = \"lightblue\") + \n  coord_flip() + \n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n2.5.5 Exercise\n\n\nCreate a comparative boxplot using the iris dataset that includes the following features:\n\nCompares Sepal.Length for each Species;\nHorizontal boxplots (more than one way to do this);\nSepal.Length is originally measured in millimeters (mm); convert this to meters (m) for this plot;\nMore informative axis label for Sepal.Length based on new scale;\nA cool theme (try a few!).",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#bar-graphs",
    "href": "visualizations.html#bar-graphs",
    "title": "\n2  Visualizations\n",
    "section": "\n2.6 Bar graphs",
    "text": "2.6 Bar graphs\n\n2.6.1 Bar graphs\n\nA bar graph (also known as bar chart or bar plot) is used for categorical data and assigns a height of a bar to the count of a group.\nComparisons are made easier with visuals than just numbers (although keep in mind that sometimes simpler is better and a table suffices).\nJust like a boxplot, a bar graph is not plotting the raw data itself. Rather it uses a summary of the data, specifically the frequency (or relative frequency = frequency / total)\nThere are two ways we can use geom_bar() to make our bar graph, and it depends on the structure of the data.\n\n2.6.2 geom_bar() wtih raw data\n\nOne way to make a bar graph is to just use the raw data and let geom_bar() convert the data into counts behind the scenes, as shown below.\nLets take a look at the data before plotting.\n\n\n\n\n\n\n\ncarat\n\n\ncut\n\n\ncolor\n\n\nclarity\n\n\ndepth\n\n\ntable\n\n\nprice\n\n\nx\n\n\ny\n\n\nz\n\n\n\n\n\n0.23\n\n\nIdeal\n\n\nE\n\n\nSI2\n\n\n61.5\n\n\n55\n\n\n326\n\n\n3.95\n\n\n3.98\n\n\n2.43\n\n\n\n\n0.21\n\n\nPremium\n\n\nE\n\n\nSI1\n\n\n59.8\n\n\n61\n\n\n326\n\n\n3.89\n\n\n3.84\n\n\n2.31\n\n\n\n\n0.23\n\n\nGood\n\n\nE\n\n\nVS1\n\n\n56.9\n\n\n65\n\n\n327\n\n\n4.05\n\n\n4.07\n\n\n2.31\n\n\n\n\n0.29\n\n\nPremium\n\n\nI\n\n\nVS2\n\n\n62.4\n\n\n58\n\n\n334\n\n\n4.20\n\n\n4.23\n\n\n2.63\n\n\n\n\n0.31\n\n\nGood\n\n\nJ\n\n\nSI2\n\n\n63.3\n\n\n58\n\n\n335\n\n\n4.34\n\n\n4.35\n\n\n2.75\n\n\n\n\n0.24\n\n\nVery Good\n\n\nJ\n\n\nVVS2\n\n\n62.8\n\n\n57\n\n\n336\n\n\n3.94\n\n\n3.96\n\n\n2.48\n\n\n\n\n\n\n\n\nBy “raw data”, we mean there is one row for each observation. When this is the case, we don’t have to change any options in geom_bar().\n\n\nggplot(data = diamonds,\n       aes(x = cut)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n2.6.3 geom_bar() wtih count data\n\nAnother way is to manually create the counts dataframe (aka frequency table) and make the bar graph from this summarized data.\nThere are multiple ways to calculate the frequencies of each group in a dataframe. Two ways are shown below, using Base R table() and the other using a tidyverse function dplyr::count().\n\n\nclass(table(cut = diamonds$cut))\n\n[1] \"table\"\n\ndata.frame(table(cut = diamonds$cut))\n\n\n\n\n\ncut\n\n\nFreq\n\n\n\n\n\nFair\n\n\n1610\n\n\n\n\nGood\n\n\n4906\n\n\n\n\nVery Good\n\n\n12082\n\n\n\n\nPremium\n\n\n13791\n\n\n\n\nIdeal\n\n\n21551\n\n\n\n\n\n\ncut_table &lt;- count(diamonds, cut)\nglimpse(cut_table)\n\nRows: 5\nColumns: 2\n$ cut &lt;ord&gt; Fair, Good, Very Good, Premium, Ideal\n$ n   &lt;int&gt; 1610, 4906, 12082, 13791, 21551\n\n\n\nNow we have the frequency table, we can go into plotting it. But it will be different than how we used geom_bar() last time because we are giving it already summarized data.\nSpecifically we have the group label (our x) and the now specified count (height, y); so, we need to tell geom_bar() to not do any statistical transformation on these variables (i.e. don’t count again). To do this, we use the option stat = \"identity\".\n\n\nggplot(data = cut_table,\n       aes(x = cut,\n           y = n)) + \n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n\n\nJust like with most things, there is still another way to do this: geom_col() treats the y aesthetic as heights directly and we don’t have to specify anything else.\n\n\nggplot(data = cut_table,\n       aes(x = cut,\n           y = n)) + \n  geom_col()\n\n\n\n\n\n\n\n\n\n\n2.6.4 Exercise\n\nCopy the code below that creates a sample of the iris data and then create a bar graph of Species. HINT: Make sure to inspect the data first.\n\n\n\n# create a sample from of data and summarize\n# -&gt; rename so in slightly different format than example and have to work with it\niris_sample &lt;- iris %&gt;% \n  sample_n(size = 50) %&gt;% \n  count(Species) %&gt;% \n  rename(Count = n)\n\n# create bar graph\n\n\n2.6.5 Displays for bivariate categorical data\n\n2.6.6 Stacked bar graph\n\nA common extension of a barplot is to show the breakdown of a second categorical variable within each bar. One way to do this is with a stacked bar graph.\nWe can again use geom_bar() (and let it do the counting). In order to differentiate between the two variables, we can specify fill in the aes(), just like we did with geom_histogram().\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = clarity)) + \n  geom_bar()\n\n\n\n\n\n\n\n\n\n\nNotice that the y-axis on the plot is count, so all of the bars and segments are based on the frequency.\n\n2.6.7 Proportionally stacked bar graph\n\nIf we want the plot to be more standardized-ish, we can make a proportionally stacked bar graph by specifying position = \"fill\". This makes each bar have the same height and the segments corresponding to the second variable are broken out by percentage within each individual bar.\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = clarity)) + \n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n\n\nThis makes across group comparisons valid and easier because segments are no longer based on potentially very different sample sizes (technically, we are plotting the conditional distributions of clarity for each type of cut).\nThe advantage of this display is that we can see if there are differences in the distributions of clarity across each cut (regardless of how many total diamonds belong to each cut).\n\n2.6.8 Side-by-side bar graph\n\nWe can also incorporate the second variable by having side-by-side bars rather than stacked. To do this, we just have to set position = \"dodge\".\n\n\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = clarity)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n\n\nThis display may tell a better story if it is important to keep an idea of sample size for each group combination. We can still tell that there are the most “Ideal” cut diamonds.\n\n2.6.9 Exercise\n\nCreate a few different displays using the diamonds dataset that visualize cut and color together. Can you notice any trends or lack-thereof between the two variables? Explain.",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#line-plots",
    "href": "visualizations.html#line-plots",
    "title": "\n2  Visualizations\n",
    "section": "\n2.7 Line plots",
    "text": "2.7 Line plots\n\n2.7.1 geom_line()\n\nAnother type of plot is a line plot. These are most commonly used when looking at a quantitative variable across time periods (aka time series data).\nBelow is a look at the example data sunspot.year. As usual we should get familiar with the data first.\n\n\nglimpse(sunspot.year)\n\n Time-Series [1:289] from 1700 to 1988: 5 11 16 23 36 58 29 20 10 8 ...\n\n\n\nBefore plotting, we need to turn this into a dataframe and add a column indicating the year.\n\n\ndata_sun &lt;- data.frame(year = c(1700:1988),\n                       sunspots = as.vector(sunspot.year))\nglimpse(data_sun)\n\nRows: 289\nColumns: 2\n$ year     &lt;int&gt; 1700, 1701, 1702, 1703, 1704, 1705, 1706, 1707, 1708, 1709, 1…\n$ sunspots &lt;dbl&gt; 5, 11, 16, 23, 36, 58, 29, 20, 10, 8, 3, 0, 0, 2, 11, 27, 47,…\n\n\n\nThis is an easy plot to make, just use geom_line() and specify the x, which is usually time, and y within the aes().\n\n\nggplot(data = data_sun,\n       aes(x = year,\n           y = sunspots)) + \n  geom_line()",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#facets",
    "href": "visualizations.html#facets",
    "title": "\n2  Visualizations\n",
    "section": "\n2.8 Facets",
    "text": "2.8 Facets\n\n2.8.1 Facets\n\nFacets (think subplots) are a data-driven feature that can be used to compare distributions based on the levels of other variables.\nVisually, this is done by splitting plots into different panels rather than one overall panel. There are multiple ways this can be done within ggplot2.\n\n2.8.2 facet_wrap()\n\nIf we are facetting by one categorical variable, we want to use facet_wrap(~ var).\nNote: the tilde ~ is used to make formula in R.\nLet’s create a scatterplot and add facets for cut to demonstrate this.\n\n\nggplot(data = diamonds,\n       aes(x = table,\n           y = depth)) + \n  geom_point() + \n  facet_wrap(~ cut)\n\n\n\n\n\n\n\n\n\n\nWe see that facet_wrap() “wraps” the panels for a single factor rectangularly, which is ideal when there are many levels for the factor.\n\n2.8.3 Controlling rows and columns\n\nIf we want to control how the panels are wrapped because we are trying to highlight some aspect, we can specify how many rows or columns of panels using the options nrow and ncol.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_boxplot() + \n  facet_wrap(~ cut,\n             ncol = 1)\n\n\n\n\n\n\n\n\n\n\nJust be careful of overplotting, don’t want too many panels stacked together.\n\n\nggplot(data = diamonds,\n       aes(x = price)) + \n  geom_histogram() + \n  facet_wrap(~ clarity,\n             ncol = 1)\n\n\n\n\n\n\n\n\n\n\n2.8.4 Scales for facets\n\nBy default, all the panels will have the same scale for the numeric variable. This can distort some plots as shown below.\n\n\nggplot(data = diamonds,\n       aes(x = price)) + \n  geom_histogram() + \n  facet_wrap(~ cut)\n\n\n\n\n\n\n\n\n\n\nTo make the plots more readable, we can add an option to allow panels to have scales (min, max, tick marks, etc.) based on only the data in the respective panel, rather than the collective data.\nThis is done via the scales argument; options are \"free_x\", \"free_y\" or \"free\" (both \\(x\\) and \\(y\\) scales are free).\nNow we can correct the above plot.\n\n\nggplot(data = diamonds,\n       aes(x = price)) + \n  geom_histogram() + \n  facet_wrap(~ cut,\n             scales = \"free_y\")\n\n\n\n\n\n\n\n\n\n\nThis is another way to display numerical distributions for multiple groups. The advantage of creating multiple histograms is that they can show prevalence (i.e. frequencies) and modality of the distributions, whereas boxplots cannot.\n\n2.8.5 Exercise\n\n\nCreate a boxplots using the iris dataset that includes the following features:\n\nPlots Sepal.Length faceted by Species;\nStack the facets vertically to emphasize the differences between each Species;\nThink about if we want to adjust the scales of the panel, why or why not?\n\n\nNote that we made this plot previously with comparitive boxplots by specifying aes(y = Species); so this is an alternative.\n\n2.8.6 facet_grid()\n\nIf we want to facet by two categorical variables, we should use facet_grid(var1 ~ var 2) as it can make a matrix of panels.\nNote that var1 (before ~) represents the rows and var2 (after) is the columns.\nLets create boxplots for each combination of cut and color for the diamonds dataset.\n\n\nggplot(data = diamonds,\n       aes(x = table)) + \n  geom_boxplot() + \n  facet_grid(cut ~ color)\n\n\n\n\n\n\n\n\n\n\nNote that when using facet_grid(), we may need to fix the scales in the same way as with facet_wrap(). And just because we can make the plot means that it is good…\n\n2.8.7 Exercise\n\nCopy the code below that creates a sample from the diamonds dataset and create scatterplots of carat vs price that is colored by cut and facetted by color and clarity. Try a few different options for scales to see how they affect the plot.\n\n\n# create a sample from of data with fewer levels (variety from ordinal scale of each)\ndiamonds_sample &lt;- diamonds %&gt;% \n  filter(cut %in% unique(diamonds$cut)[c(1,3,5)],\n         color %in% unique(diamonds$color)[c(1,4,7)],\n         clarity %in% unique(diamonds$clarity)[c(1,4,8)]) %&gt;% \n  sample_n(size = 5000)",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#density-histograms-and-density-curves",
    "href": "visualizations.html#density-histograms-and-density-curves",
    "title": "\n2  Visualizations\n",
    "section": "\n2.9 Density histograms and density curves",
    "text": "2.9 Density histograms and density curves\n\n2.9.1 Density histograms\n\nAs we saw in the previous topic, if comparing a numeric distribution for a categorical explanatory variable, multiple histograms are a good option. But we had to allow varying scales between panels in order to have a readable plot.\nAnother option if we are not concerned with counts (sample size), but rather shape and modality across groups, is to make the heights of bars proportional.\nWe can think of this as each histogram having the same amount of “ink”, whcih is done by adding the condition that total heights must sum to 1. In essence, this standardizes heights.\nTo do this, we map y = after_stat(density) in the aes() statement (we won’t dig into how this works).\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = after_stat(density))) + \n  geom_histogram() + \n  facet_wrap(~ cut)\n\n\n\n\n\n\n\n\n\n\nThis can of course be done for a single histogram too.\n\n2.9.2 Density curves\n\nA density curve is related to the density histograms we just showed.\nAs we have seen, (density) histograms are really choppy binned representations of data whose display can vary widely based on our selection of bin width / number of bins.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           y = after_stat(density))) + \n  geom_histogram(bins = 50)\n\n\n\n\n\n\n\n\n\n\nA more objective way to represent the data is called a density curve, which is a smooth curve based off the observed data that has an area under the curve (AUC) of 1.\nWe can think of this smooth curve as a blanket thrown over the top of our density histogram as shown below.\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how the density curve still reflects the overall pattern of histograms, but it is much smoother.\nTo create this by itself, use geom_density().\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_density()\n\n\n\n\n\n\n\n\n\n\n2.9.3 Exercise\n\n\nUse the iris dataset to do the following:\n\nCreate a density histogram of Petal.Length;\nOverlay a density curve of Petal.Length. HINT: You can plot multiple geoms on the same plot simply by adding another layer.\n\n\n\n2.9.4 Multiple density curves\n\nDensity curves provide us with yet another way to visualize a quantitative distribution by group.\nDrawing multiple lines (density curves) on the same plot is often better than many histograms, because the histograms would have to be stacked.\nTo distinguish between different groups when working with lines, we could use the aesthetics linetype or color (color will likely be easier to read, especially for several groups).\nWe can also add some other options to make the lines stand out more.\n\n\nggplot(data = diamonds,\n       aes(x = carat,\n           color = cut)) + \n  geom_density(linewidth = 0.75)\n\n\n\n\n\n\n\n\n\n\nJust be careful to not let the plot to get jumbled / messy with too many lines.\n\n2.9.5 Amount of smoothing\n\nOne way to tweak the resulting curve is to change the amount of smoothing, which is a statistical parameter (not just a visual one like binwidth). To do this, use the adjust parameter.\nIf adjustment is larger (e.g. adjust = 2), then the probability is more spread out and there is less smoothing; if smaller (e.g adjust = 0.2), then the smoothing is more sensitive and picks up on smaller patterns / spikes in the data.\n\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_density(adjust = 2)\n\n\n\n\n\n\n\n\n\n\n2.9.6 Exercise\n\n\nUse the iris dataset to do the following:\n\nCreate density curves of a Petal.Length colored by each Species;\nAdjust the amount of smoothing to find a level that shows the overall trends well with some detail, but that is not overly exact (it’s a balance);\nAdd fill = Species in the aes() statement to see the result of this;\nNotice how the colors are completely opaque (not “see through”). To make them more transparent, add the following option locally geom_density(alpha = 0.5). Try a few different values (0 \\le alpha \\le 1) to see the result. Note that this option can also be used with lots other geom_*() as well.\nWhat does this plot tell us about the petal lengths of the different species?",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#application",
    "href": "visualizations.html#application",
    "title": "\n2  Visualizations\n",
    "section": "\n2.10 Application",
    "text": "2.10 Application\n\n2.10.1 Recreating\n\nNow we will return to the plots in the beginning of this section and recreate them.\n\n\n# load basketball data\nload(\"tutorials/visualizations/www/data-bsu-game.RData\")\n\n# filter to most recent season and take out the few neutral games\ndata_bsu_plot &lt;- bsu_game %&gt;% \n  filter(Season == max(Season),\n         Location != \"Neutral\")\n\n\n# line plot of points over the season\n# -&gt; specific colors by W/L and also take into account location with either the points (Visual 1)\n# -&gt; add reference line for average points\nggplot(data = data_bsu_plot,\n       aes(x = Date,\n           y = Points)) + \n  geom_point(aes(color = Outcome,\n                 shape = Location),\n             size = 4) + \n  geom_line(color = \"lightgrey\") + \n  geom_hline(aes(yintercept = mean(Points)),\n             color = \"grey20\",\n             linetype = \"dashed\") + \n  scale_color_manual(values = c(\"L\" = \"red\", \"W\" = \"green\")) + \n  scale_shape_manual(values = c(\"Home\" = 19, \"Away\" = 5, \"Neutral\" = 8)) + \n  labs(title = \"Ball State Basketball 2012-13 Visual 1\") + \n  theme_bw()\n\n\n\n\n\n\n\n\n\n\n2.10.2 Exercise\n\nCopy the final code used to create `Visual 1’ from above and modify it to recreate ‘Visual 2’.",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  },
  {
    "objectID": "visualizations.html#exercise-solutions",
    "href": "visualizations.html#exercise-solutions",
    "title": "\n2  Visualizations\n",
    "section": "\n2.11 Exercise solutions",
    "text": "2.11 Exercise solutions\nExercise 2.3.3\n\nggplot(data = diamonds,\n       aes(x = table,\n           y = depth)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nExercise 2.3.6\n\n# create sample\ndiamonds_sample &lt;- sample_n(diamonds, size = 100)\n\n# create scatterplot\nggplot(data = diamonds_sample,\n       aes(x = table,\n           y = depth,\n           size = carat)) +\n  geom_point(shape = 5)\n\n\n\n\n\n\n\n\n\nExercise 2.4.2\n\nggplot(data = diamonds,\n       aes(x = carat)) + \n  geom_histogram(bins = 20,\n                 fill = \"white\",\n                 color = \"black\")\n\n\n\n\n\n\n\n\n\nExercise 2.4.4\n\nggplot(data = iris,\n       aes(x = Sepal.Length,\n           fill = Species)) + \n  geom_histogram() + \n  labs(title = \"Sepal Length by Species\",\n       x = \"Sepal Length (cm)\")\n\n\n\n\n\n\n\n\n\nExercise 2.5.2\n\nggplot(data = iris,\n       aes(y = Sepal.Length)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nExercise 2.5.5\n\n# NOTE: if have X and Y aesthetics swapped, can use coord_flip() to get horizontal boxplots without changing your aes() statement\nggplot(data = iris,\n       aes(x = Species,\n           y = Sepal.Length / 10)) +  \n  geom_boxplot() + \n  labs(y = \"Sepal Length (m)\") + \n  theme_light()\n\n\n\n\n\n\n\n\n\nExercise 2.6.4\n\n# create a sample from of data and summarize\n# -&gt; rename so in slightly different format than example and have to work with it\niris_sample &lt;- iris %&gt;% \n  sample_n(size = 50) %&gt;% \n  count(Species) %&gt;% \n  rename(Count = n)\n\n# preview dataset to figure out structure\nglimpse(iris_sample) #-&gt; count (summarized) data\n\nRows: 3\nColumns: 2\n$ Species &lt;fct&gt; setosa, versicolor, virginica\n$ Count   &lt;int&gt; 19, 14, 17\n\n# create bar graph\n# -&gt; way 1)\nggplot(data = iris_sample,\n       aes(x = Species,\n           y = Count)) + \n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n# -&gt; way 2)\nggplot(data = iris_sample,\n       aes(x = Species,\n           y = Count)) + \n  geom_col()\n\n\n\n\n\n\n\n\n\n?sec-bargraph-2vars-ex\n\n# two of several plots that could be made\n\n# side-by-side bar graphs\nggplot(data = diamonds,\n       aes(x = color,\n           fill = cut)) + \n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\n# proportionally stacked bar graph\nggplot(data = diamonds,\n       aes(x = cut,\n           fill = color)) + \n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\n# trends\n# -&gt; colors E, F, amd G are the three most common\n# -&gt; distributions of color are relatively the same across cuts (i.e. about same proportion of diamonds for each color regardless of cut)\n\nExercise 2.8.5\n\nggplot(data = iris,\n       aes(x = Sepal.Length)) +  \n  geom_boxplot() + \n  facet_wrap(~ Species,\n             ncol = 1)\n\n\n\n\n\n\n\n\n# we do NOT want to use scales = \"free_x\" because in order to have an equal comparison of the boxplots across species, we need them to be on the same scale\n\nExercise 2.8.7\n\n# create a sample from of data with fewer levels (variety from ordinal scale of each)\ndiamonds_sample &lt;- diamonds %&gt;% \n  filter(cut %in% unique(diamonds$cut)[c(1,3,5)],\n         color %in% unique(diamonds$color)[c(1,4,7)],\n         clarity %in% unique(diamonds$clarity)[c(1,4,8)]) %&gt;% \n  sample_n(size = 5000)\n\n# create facetted scatterplots\nggplot(data = diamonds_sample,\n       aes(x = carat,\n           y = price,\n           color = cut)) + \n  geom_point() + \n  facet_grid(color ~ clarity,\n             scales = \"free\") # both X and Y axes to be free (for the grid, not each individual panel)\n\n\n\n\n\n\n\n\n\nExercise 2.9.3\n\nggplot(data = iris,\n       aes(x = Petal.Length,\n           y = after_stat(density))) + \n  geom_histogram() + \n  geom_density()\n\n\n\n\n\n\n\n\n\nExercise 2.9.6\n\nggplot(data = iris,\n       aes(x = Petal.Length,\n           color = Species,\n           fill = Species)) + \n  geom_density(adjust = 1,\n               alpha = 0.5)\n\n\n\n\n\n\n\n\n# two of the species have similar petal lengths, while one is well below the others\n\nExercise 2.10.2\n\n# line plot of points over the season\n# -&gt; specific colors by W/L and also take into account location with facet (Visual 2)\n# -&gt; add reference line for average points\nggplot(data = data_bsu_plot,\n       aes(x = Date,\n           y = Points)) + \n  geom_point(aes(color = Outcome,\n                 shape = Location),\n             size = 4) + \n  geom_line(color = \"lightgrey\") + \n  geom_hline(aes(yintercept = mean(Points)),\n             color = \"grey20\",\n             linetype = \"dashed\") + \n  scale_color_manual(values = c(\"L\" = \"red\", \"W\" = \"green\")) + \n  scale_shape_manual(values = c(\"Home\" = 19, \"Away\" = 5, \"Neutral\" = 8)) + \n  labs(title = \"Ball State Basketball 2012-13 Visual 1\") + \n  theme_bw()\n\n\n\n\n\n\n\n\nggplot(data = data_bsu_plot,\n       aes(x = Date,\n           y = Points)) +  \n  geom_point(aes(color = Outcome),\n             size = 4) + \n  geom_line(color = \"lightgrey\") + \n  geom_hline(aes(yintercept = mean(Points)),\n             color = \"grey20\",\n             linetype = \"dashed\") + \n  scale_color_manual(values = c(\"L\" = \"red\", \"W\" = \"green\")) + \n  facet_wrap(~ Location) + \n  labs(title = \"Ball State Basketball 2012-13 Visual 2\") + \n  theme_bw()",
    "crumbs": [
      "Course Notes",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Visualizations</span>"
    ]
  }
]